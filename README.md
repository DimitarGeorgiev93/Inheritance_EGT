# Inheritance_EGT
1. В софтуерна фирма има два вида служители – програмисти и мениджъри. Отдел “личен състав” поддържа следната информация за всеки от програмистите:
    * потребителско име;
    * стаж (в месеци);
    * заплата;
    * дали знае C++.
И следната информация за всеки от мениджърите:
    * потребителско име;
    * стаж (в месеци);
    * заплата;
    * колко човека управлява.
Да се напише програма, която позволява на отдел “личен състав” да поддържа списък с всички програмисти и мениджъри във фирмата. Програмата да може да извършва следните операции:
    * постъпване на нов служител;
    * напускане на служител;
    * извеждане на списък с данни за всички служители.

Да се въведат примерни данни за служители в софтуерна фирма и над тях да се изпълнят следните операции:
    * изтриване на всички служители, които имат стаж по-малко от 3 месеца;
    * увеличаване на заплатата на всички служители с 1% от текущото им възнаграждение за всяка година стаж.
    
2. 
2.1. Да се дефинира структура ChessPosition, описваща коректна позиция на фигура върху шахматна дъска (‘A’-‘H’,1-8).
 Да се дефинира абстрактен клас ChessPiece, описващ шахматна фигура със следните операции:
    * ChessPosition getPosition(): Дава позицията на фигурата на дъската;
    * [подходящ тип] allowedMoves(): Дава списък с всички възможни позиции, до които дадена фигура може да достигне с един ход;
    * bool wins(ChessPosition): Проверява дали фигурата “владее” дадена позиция, т.е. дали позицията е в списъка с възможни ходове на фигурата.
2.2. Да се дефинират класовете Queen, Rook и Knight - наследници на ChessPiece, описващи съответно шахматните фигури царица, топ и кон.
2.3. “Стабилна конфигурация” наричаме такава подредба на фигурите по дъската, при която никоя фигура да не е върху позволен ход на друга фигура (т.е. никои две фигури не се “бият”).
Да се дефинира функция allMoves ([подходящ тип] pieces[, ...]), която по списъка pieces, съдържащ произволен брой разнородни шахматни фигури, 
отпечатва на конзолата всеки възможен ход на фигура от pieces такъв, че след изпълнението му списъка с фигури представлява стабилна конфигурация. 
Информацията за ходовете да съдържа типа на фигурата, старата позиция и новата позиция, например:
    Queen A1 -> B2
    Knight B3 -> A5
    
3. Да се реализира следната йерархия от класове:
   Vehicle
  /       \
Land     Water
  \       /
   Amphibia
   
3.1. Клас Vehicle с член-данни име, модел, височина и тегло. Да се реализират член-функции:
    * bool canPassUnderBridge(float) const, която проверява дали превозното средство може да мине под мост с определена височина;
    * bool canPassOverBridge(float) const, която проверява дали превозното средство може да мине по мост, който издържа товар с определено тегло (в тонове).

3.2. Клас LandVehicle с член-данни максимална скорост и конски сили. Да се реализират следните член-функции:
    * float getTime(float) const, която връща за колко време може да се изминат определен брой километри, ако се движи с максимална скорост.

3.3. Клас WaterVehicle с член-данни водоизместимост и максимална скорост (във възели). Да се реализират следните член-функции:
    * float getSpeedUpStream(float speadStream) const, която намира скоростта на кораба срещу течението;
    * float getSpeedDownStream(float) const, която намира скоростта на кораба по течението;
    * float getTimeUpStream(float, float) const, която намира за колко време корабът може да измине определен брой морски мили, ако се движи срещу течението;
    * float getTimeDownStream(float, float) const, която намира за колко време корабът може да измине определен брой морски мили, ако се движи по течението.

3.4. Клас AmphibiousVehicle, който описва превозно средство, което може да се движи както по суша, така и по вода.

3.5. Да се напише функция, която проверява дали амфибията може да мине през определено разстояние за по-малко от час. 
Пътят включва 5 км по суша, среща на мост с височина 5 м, след което 5 км по вода, срещу течение със скорост 10 възела.
